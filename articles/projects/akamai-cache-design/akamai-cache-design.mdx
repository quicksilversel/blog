---
title: 'Designing a Tag-Based Akamai Cache Invalidation System'
description: 'Learn how we built an event-driven infrastructure to purge Akamai cache efficiently when publishing content from headless CMS, using API Gateway and AWS Lambda.'
topics: ['akamai', 'graphql']
published: true
date: '2024-12-03'
---

## ğŸ§Š Introduction

Caching gets tricky when URLs change constantly (e.g. when query params include timestamps)

We were building a system that used GraphQL to serve real-time data from headless CMS, where URLs changed every day because of a date parameter. That made traditional URL-based cache busting impossible.

So we dropped URL-based caching entirely and built a tag-based, event-driven invalidation system instead. Cache purges happen automatically when content is published â€” not when the URL changes.

## ğŸ˜µâ€ğŸ’« The Problem: Unstable URLs Broke Caching

The GraphQL query we used required a date parameter to fetch time-sensitive data:

```graphql
query getData($date: Calendar) {
  itemList(
    filter: {
      startAt: { _expressions: [{ value: $date, _operator: AT_OR_BEFORE }] }
      endAt: { _expressions: [{ value: $date, _operator: AT_OR_AFTER }] }
    }
  ) {
    items {
      ... // response fields
    }
  }
}
```

Because the date changed daily, it produced a new URL every time:

```
https://<your-graphql-endpoint>?...&date=2024-09-07T00:00:00Z
```

This broke caching: Akamai treated each URL as unique, even if the underlying content hadnâ€™t changed.

## ğŸ’¡ The Fix: Cache by Tag, Not URL

Instead of relying on URLs, we built a system that:

1. Caches GraphQL responses in Akamai with a custom tag
2. On publish, sends a cache purge request to Akamai using that tag

The image below shows the overall architecture:

![diagram](/cache-design/diagram.png)

### Triggering Cache Purge from headless CMS

In most headless CMS platforms, itâ€™s possible to set up custom actions that fire when specific events occur â€” such as publishing content. We configured a trigger to send a request to API Gateway whenever content is updated.

That request includes key metadata (like what content was affected) in the request header. The backend (lambda) extracts this info, builds a cache tag, and uses it to invalidate Akamai cache.

### Why Tags?

- URLs were unstable due to date params
- Tags provide a stable, content-based way to track what to purge
- Akamai supports tag-based purging, which is fast and clean

## ğŸ·ï¸ Tag & Cache Key Design

### ğŸ”– Cache Tags

- Tag value was extracted from the request header
- Sanitized to remove invalid characters (=, ;, spaces, etc.)

### ğŸ§© Cache Key Logic

- Excluded date from the cache key so content appears â€œstaticâ€
- Origin requests still included the date param to maintain filtering behavior
- Result: cache is reused across dates until a purge happens

## ğŸ“¦ When does the cache purge happen?

On publish:

1. User publishes content in headless CMS
2. headless CMS fires a custom HTTP request to API Gateway
3. Lambda reads the tag from the header and calls Akamaiâ€™s purge API
4. Akamai clears the matching cache
5. Updated content is reflected on the site (usually within 20â€“30 sec)

## ğŸ§  Final Thoughts

- Query param-based URLs make caching hard - this was quite a challenge!
- Tags provide a stable, efficient way to manage cache
- Event-driven purging keeps content fresh without manual intervention
