---
title: '[Docker] Speeding Up Next.js Docker Builds with GitHub Actions Cache'
description: 'How I fixed painfully slow Docker builds by implementing Next.js build caching that works with GitHub Actions.'
topics: ['GHA', 'Docker', 'Next.js']
published: true
date: '2025-10-10'
---

## The Problem

Every push triggered a full Next.js rebuild in our Docker-based CI/CD. Webpack recompiled everything, pages were regenerated, and builds took forever ğŸ˜‡

Meanwhile, our native `npm run build` on GitHub Actions was blazing fast thanks to Next.js's built-in caching.

Docker was killing our velocity.

## How Next.js Build Cache Works

Next.js stores build artifacts in `.next/cache` to speed up subsequent builds:

- **Webpack compilation cache** - Compiled modules and chunks
- **TypeScript cache** - Type checking results (`.tsbuildinfo`)
- **SWC cache** - Transformed JavaScript/TypeScript files
- **Image optimization cache** - Processed images

When you run `npm run build` again, Next.js checks this cache. If source files haven't changed, it skips recompiling them. This can cut build times from minutes to seconds.

In a native environment (like directly on a GitHub Actions runner), this just works. The `.next/cache` directory persists between builds.

But in Docker? Each build starts fresh. The cache gets created, used during that single build, then thrown away when the container exits.

## Why Docker Wasn't Caching

I tried BuildKit cache mounts:

```dockerfile
RUN --mount=type=cache,target=/app/.next/cache \
    npm run build
```

And GitHub Actions cache:

```yaml
cache-from: type=gha
cache-to: type=gha,mode=max
```

But builds stayed slow. Every. Single. Time.

Turns out **GitHub Actions cache backend doesn't properly export BuildKit cache mounts**. The cache was created but never persisted.

## The Solution

The key: explicitly move the Next.js cache in and out of Docker containers.

### 1. Restore Cache Before Docker Build

```yaml
- name: Cache Next.js build
  uses: actions/cache@v4
  with:
    path: .next/cache
    key: ${{ runner.os }}-nextjs-docker-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-nextjs-docker-
```

This restores `.next/cache` to the runner before building the Docker image.

### 2. Include Cache in Docker

Create `.dockerignore` that excludes heavy stuff but NOT `.next/`:

```
node_modules
.git
.github
```

Now `COPY . .` includes the restored cache.

### 3. Extract Cache After Build

After Docker build, extract the updated cache:

```yaml
- name: Extract Next.js cache from container
  run: |
    CONTAINER_ID="$(docker create ${{ env.DOCKER_IMAGE_REPO }}:${{ env.DOCKER_IMAGE_TAG }})"
    mkdir -p .next
    docker cp "${CONTAINER_ID}:/app/.next/cache" .next/cache
    docker rm "${CONTAINER_ID}"
```

GitHub Actions auto-saves it at job end.

## Don't Make This Mistake

I initially used `${{ github.sha }}` in the cache key:

```yaml
key: ${{ runner.os }}-nextjs-docker-${{ github.sha }} # âŒ Wrong!
```

Every commit got a unique cache key. Useless.

Fix: base it on `package-lock.json`:

```yaml
key: ${{ runner.os }}-nextjs-docker-${{ hashFiles('**/package-lock.json') }} # âœ… Right!
```

Cache persists across commits, only invalidates when dependencies change.

## The Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. GitHub Actions restores cache    â”‚
â”‚    .next/cache â†’ runner filesystem  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. Docker build copies cache        â”‚
â”‚    COPY . . â†’ includes cache        â”‚
â”‚    npm run build â†’ reuses cache     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Extract updated cache             â”‚
â”‚    docker cp â†’ pull cache from       â”‚
â”‚    container to runner               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. GHA auto-saves for next build    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Complete Workflow

```yaml
- name: Cache Next.js build
  uses: actions/cache@v4
  with:
    path: .next/cache
    key: ${{ runner.os }}-nextjs-docker-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-nextjs-docker-

- name: Set up Docker Buildx
  uses: docker/setup-buildx-action@v3

- name: Build image
  uses: docker/build-push-action@v6
  with:
    context: .
    file: dockerfiles/nextjs/Dockerfile
    load: true
    tags: my-app:latest
    outputs: type=docker
    cache-from: type=gha
    cache-to: type=gha,mode=max

- name: Extract Next.js cache from container
  run: |
    CONTAINER_ID="$(docker create my-app:latest)"
    mkdir -p .next
    docker cp "${CONTAINER_ID}:/app/.next/cache" .next/cache
    docker rm "${CONTAINER_ID}"
```

## Results

- **Before:** Full rebuild every time
- **After:** ~2GB of cached build artifacts reused
- **Impact:** Way faster CI/CD

## Lesson

BuildKit cache mounts don't integrate well with GitHub Actions cache. You need to explicitly manage cache persistence.

Sometimes the best solution isn't elegantâ€”it's the one that works. Don't be afraid to use `docker cp` if that's what it takes.
