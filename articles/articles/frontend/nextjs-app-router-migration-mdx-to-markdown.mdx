---
title: 'Next.js App Router Migration: From next-mdx-remote to gray-matter'
description: 'A deep dive into migrating from Pages Router to App Router, replacing next-mdx-remote with gray-matter and react-markdown. Includes analysis of markdown parsing libraries under the hood.'
date: 2025-12-30
topics: ['Next.js', 'React']
published: true
---

## The Migration Context

After upgrading to Next.js 16 with React 19, I decided it was time to migrate my blog from the Pages Router to the App Router. What started as a routing migration quickly turned into a deeper exploration of markdown processing libraries when I discovered that `next-mdx-remote` doesn't play well with React Server Components.

This article covers the technical decisions behind the migration, with a focus on understanding how each library works under the hood.

## Why next-mdx-remote Had to Go

[next-mdx-remote](https://github.com/hashicorp/next-mdx-remote) was designed for the Pages Router era. It serializes MDX content on the server (in `getStaticProps`) and hydrates it on the client. The problem? This architecture fundamentally conflicts with React Server Components.

### The Technical Issue

`next-mdx-remote` works in two phases:

```tsx
// Phase 1: Server-side serialization (getStaticProps)
const mdxSource = await serialize(content)

// Phase 2: Client-side hydration
<MDXRemote {...mdxSource} components={components} />
```

The serialization produces a compiled JavaScript function that needs to be hydrated on the client. In the App Router, Server Components can't use this pattern because:

1. Server Components don't hydrate - they render once on the server
2. The `MDXRemote` component requires client-side React context
3. Passing serialized MDX through the RSC wire format causes issues

I realized I was using MDX as overkill anyway. My blog posts were plain markdown with frontmatter - no embedded React components. This made it the perfect opportunity to switch to a simpler stack.

## Choosing a Markdown Stack

I needed two things: a frontmatter parser and a markdown renderer. Let me break down the options I considered.

### Frontmatter Parsing: gray-matter

[gray-matter](https://github.com/jonschlinkert/gray-matter) is the de facto standard for parsing YAML frontmatter from markdown files. Here's what makes it interesting under the hood.

#### How gray-matter Works

At its core, gray-matter uses a simple but clever approach:

```javascript
// Simplified internal logic
function parse(str) {
  // 1. Detect frontmatter delimiters (---)
  const match = str.match(/^---\n([\s\S]*?)\n---/)

  // 2. Extract and parse YAML using js-yaml
  const frontmatter = yaml.load(match[1])

  // 3. Return content after frontmatter
  const content = str.slice(match[0].length)

  return { data: frontmatter, content }
}
```

The actual implementation is more sophisticated, handling:

- **Multiple delimiters**: Supports `---`, `~~~`, or custom delimiters
- **Multiple formats**: YAML (default), JSON, TOML, or custom parsers
- **Excerpts**: Can extract a content excerpt for previews
- **Caching**: Stores parsed results to avoid re-parsing

```tsx
import matter from 'gray-matter'

const file = fs.readFileSync('post.mdx', 'utf8')
const { data, content } = matter(file)

// data = { title: 'My Post', date: '2025-01-01', ... }
// content = 'The actual markdown content...'
```

#### Why Not Alternatives?

**front-matter** (npm package): Simpler but less flexible. Only supports YAML and doesn't have the excerpt feature. gray-matter's flexibility with custom parsers and delimiters made it the better choice.

**Manual regex**: I could parse `---` blocks myself, but why reinvent the wheel? gray-matter handles edge cases like nested YAML, multiline strings, and various date formats that would be tedious to implement correctly.

### Markdown Rendering: The Options

This was the more interesting decision. I evaluated three main options:

| Library                  | Approach                 | Ecosystem             |
| ------------------------ | ------------------------ | --------------------- |
| react-markdown (unified) | AST-based transformation | remark/rehype plugins |
| marked                   | Regex-based compilation  | Custom extensions     |
| markdown-it              | Token-based parsing      | Plugin middleware     |

#### Option 1: react-markdown (unified ecosystem)

[react-markdown](https://github.com/remarkjs/react-markdown) is built on the [unified](https://unifiedjs.com/) collective, which processes content through AST (Abstract Syntax Tree) transformations.

**How unified Works Under the Hood:**

The unified pipeline has three phases:

```
Input String → Parse → Transform → Compile → Output
              (remark)  (plugins)   (rehype)
```

**Phase 1 - Parse (remark):** Converts markdown string to mdast (Markdown AST)

```javascript
// Input: "# Hello **world**"
// mdast output:
{
  type: 'root',
  children: [{
    type: 'heading',
    depth: 1,
    children: [{
      type: 'text',
      value: 'Hello '
    }, {
      type: 'strong',
      children: [{ type: 'text', value: 'world' }]
    }]
  }]
}
```

**Phase 2 - Transform (plugins):** Manipulate the AST

```javascript
// remark-gfm adds support for:
// - Tables (GridTable nodes)
// - Strikethrough (delete nodes)
// - Task lists (listItem with checked property)
// - Autolinks
```

**Phase 3 - Compile (rehype):** Convert mdast to hast (HTML AST), then to React elements

```javascript
// mdast → hast transformation
// heading { depth: 1 } → element { tagName: 'h1' }

// hast → React
// element { tagName: 'h1' } → React.createElement('h1', ...)
```

**The Plugin Ecosystem:**

The unified ecosystem's power comes from its plugin architecture. Each plugin is a function that receives and returns an AST:

```javascript
function myRemarkPlugin() {
  return (tree) => {
    visit(tree, 'text', (node) => {
      // Transform all text nodes
      node.value = node.value.toUpperCase()
    })
  }
}
```

Common plugins include `remark-gfm` for GitHub Flavored Markdown (tables, strikethrough, task lists), `rehype-slug` for auto-generating heading IDs, and `rehype-prism-plus` for syntax highlighting.

For my blog, I only use `remark-gfm`. Heading IDs are generated in the React component itself by slugifying the text content - this keeps the logic close to the styling. For syntax highlighting, I use `prism-react-renderer` instead of a rehype plugin. It's a React component that tokenizes code at render time, giving more control over styling.

#### Option 2: marked

[marked](https://github.com/markedjs/marked) takes a fundamentally different approach - it's a regex-based compiler that directly transforms markdown to HTML.

**How marked Works Under the Hood:**

marked uses a lexer-parser architecture:

```javascript
// 1. Lexer: Tokenize input using regex patterns
const tokens = marked.lexer('# Hello **world**')
// [{ type: 'heading', depth: 1, tokens: [...] }]

// 2. Parser: Convert tokens to HTML strings
const html = marked.parser(tokens)
// '<h1>Hello <strong>world</strong></h1>'
```

The lexer uses a series of regex patterns to identify markdown elements:

```javascript
// Simplified internal patterns
const rules = {
  heading: /^(#{1,6})(?:\s+(.+?))?(?:\n|$)/,
  code: /^(`{3,})([^\n]*)\n([\s\S]*?)\n\1/,
  bold: /\*\*([^*]+)\*\*/,
  // ... many more
}
```

**Pros:**

- Fast (no AST overhead)
- Simple mental model
- Small bundle size

**Cons:**

- Regex-based parsing can have edge cases
- Less flexible plugin system
- Returns HTML strings, not React elements (need `dangerouslySetInnerHTML`)

#### Option 3: markdown-it

[markdown-it](https://github.com/markdown-it/markdown-it) uses a token-based approach similar to marked but with a more structured plugin API.

**How markdown-it Works Under the Hood:**

markdown-it has a two-phase architecture with a middleware-like plugin system:

```javascript
// 1. Parse: Generate token stream
const tokens = md.parse('# Hello')
// [{ type: 'heading_open', tag: 'h1' },
//  { type: 'inline', content: 'Hello', children: [...] },
//  { type: 'heading_close', tag: 'h1' }]

// 2. Render: Convert tokens to HTML
const html = md.render('# Hello')
```

Plugins can hook into specific parsing rules:

```javascript
md.core.ruler.push('my_rule', (state) => {
  // Modify token stream
})

md.inline.ruler.before('emphasis', 'my_inline', (state, silent) => {
  // Custom inline parsing
})
```

**Pros:**

- Very extensible
- CommonMark compliant
- Battle-tested (used by many CMSs)

**Cons:**

- Plugin API has a learning curve
- Different ecosystem from unified
- Also returns HTML strings

### My Decision: react-markdown

I chose react-markdown for several reasons:

#### Native React Integration

Returns actual React elements, not HTML strings. This means no `dangerouslySetInnerHTML`, type-safe component overrides, and React DevTools shows the actual component tree.

#### Component Customization

I can pass custom components for each markdown element:

```tsx
<ReactMarkdown
  components={{
    h1: ({ children }) => <CustomH1>{children}</CustomH1>,
    pre: ({ children }) => <SyntaxHighlighter>{children}</SyntaxHighlighter>,
    a: ({ href, children }) => <SafeLink href={href}>{children}</SafeLink>,
  }}
>
  {content}
</ReactMarkdown>
```

#### Plugin Ecosystem

The remark/rehype ecosystem has plugins for everything: GFM support (tables, task lists), math rendering (KaTeX), syntax highlighting, auto-linking headings, and custom containers.

#### Future Flexibility

If I ever need MDX features again, the unified ecosystem supports it through `@mdx-js/mdx`.

## The Migration Implementation

### Project Structure Changes

```
Before (Pages Router):
src/pages/
  ├── _app.tsx
  ├── _document.tsx
  ├── index.tsx
  └── articles/[...slug].tsx

After (App Router):
src/app/
  ├── layout.tsx
  ├── page.tsx
  └── articles/[category]/[slug]/page.tsx
```

### Data Fetching Changes

The biggest paradigm shift was moving from `getStaticProps`/`getStaticPaths` to Server Components with `generateStaticParams`.

**Before:**

```tsx
// pages/articles/[...slug].tsx
export async function getStaticPaths() {
  const articles = await getArticles()
  return {
    paths: articles.map((a) => ({
      params: { slug: [a.category, a.fileName] },
    })),
    fallback: false,
  }
}

export async function getStaticProps({ params }) {
  const [category, slug] = params.slug
  const source = await serialize(content)
  return { props: { source, frontmatter } }
}

export default function ArticlePage({ source, frontmatter }) {
  return <MDXRemote {...source} components={components} />
}
```

**After:**

```tsx
// app/articles/[category]/[slug]/page.tsx
export async function generateStaticParams() {
  const articles = await getArticles()
  return articles.map(({ category, fileName }) => ({
    category,
    slug: fileName.replace('.mdx', ''),
  }))
}

export default async function ArticlePage({ params }) {
  const { category, slug } = await params
  const filePath = path.join(ARTICLE_PATH, category, `${slug}.mdx`)

  if (!fs.existsSync(filePath)) {
    notFound()
  }

  const file = fs.readFileSync(filePath, 'utf8')
  const { data: frontmatter, content } = matter(file)

  return <ArticleDetail content={content} frontmatter={frontmatter} />
}
```

### The Markdown Renderer

```tsx
'use client'

import ReactMarkdown from 'react-markdown'
import remarkGfm from 'remark-gfm'
import * as Markup from './Markup'

export const MarkdownRenderer = ({ content }: { content: string }) => {
  return (
    <ReactMarkdown
      remarkPlugins={[remarkGfm]}
      components={{
        h1: Markup.H1,
        h2: Markup.H2,
        h3: Markup.H3,
        pre: Markup.HighlightedCode,
        code: Markup.Code,
        // ... other elements
      }}
    >
      {content}
    </ReactMarkdown>
  )
}
```

### Handling Emotion with App Router

One gotcha: Emotion styled components require the `'use client'` directive in App Router. The `createContext` API used internally by Emotion doesn't work in Server Components.

I had to add `'use client'` to:

- All components using `styled` from `@emotion/styled`
- The EmotionRegistry that handles SSR style injection
- Any component using Emotion's `useTheme` hook

```tsx
// EmotionRegistry.tsx
'use client'

import { useState } from 'react'
import { useServerInsertedHTML } from 'next/navigation'
import { CacheProvider } from '@emotion/react'
import createCache from '@emotion/cache'

export default function EmotionRegistry({ children }) {
  const [cache] = useState(() => createCache({ key: 'emotion' }))

  useServerInsertedHTML(() => {
    // Extract and inject styles for SSR
  })

  return <CacheProvider value={cache}>{children}</CacheProvider>
}
```

## Performance Comparison

The migration had some nice performance benefits:

| Metric      | Before (next-mdx-remote) | After (react-markdown) |
| ----------- | ------------------------ | ---------------------- |
| Bundle size | ~45KB gzipped            | ~28KB gzipped          |
| Build time  | Serialize each MDX file  | Just read files        |
| Runtime     | Hydration required       | Pure render            |

The main wins:

- **No serialization step**: gray-matter just parses YAML, which is much faster than compiling MDX to JavaScript
- **Smaller client bundle**: react-markdown is lighter than the MDX runtime
- **Server Components**: Article pages are now true Server Components (except the markdown renderer)

## Lessons Learned

### 1. Understand What You Actually Need

I was using MDX because it was the "modern" choice, but I never used its killer feature (embedding React components in markdown). Plain markdown with gray-matter + react-markdown was sufficient and simpler.

### 2. The unified Ecosystem Is Powerful

Once you understand the AST transformation model, the unified ecosystem becomes incredibly flexible. Need to transform all links to open in new tabs? Write a rehype plugin. Need to extract all headings for a table of contents? Walk the mdast. The abstraction pays off.

### 3. App Router Changes Everything

The mental model shift from "render on server, hydrate on client" to "Server Components by default, Client Components when needed" took some adjustment. But the result is cleaner: data fetching is just async/await, and you explicitly mark interactive boundaries.

### 4. Check Library Compatibility Early

Before starting a major migration, check if your dependencies support the target architecture. I would have saved time by checking next-mdx-remote's RSC compatibility first.

## Wrapping Up

The migration from Pages Router + next-mdx-remote to App Router + gray-matter + react-markdown simplified my stack while improving performance. Understanding how each library works under the hood helped me make informed decisions rather than just following tutorials.

If you're considering a similar migration, ask yourself: do you actually need MDX? If you're just writing markdown with frontmatter, the simpler stack might be the better choice.

The code for this blog is open source if you want to see the full implementation.
